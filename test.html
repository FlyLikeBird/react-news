<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Document</title>
</head>
<body>
  <!--  <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>  -->
  <div id="test" class="test">what</div>
  <script type="text/javascript">
    
    {
    	var a=1;
    	let b=10;
    }

	var a = [];
	for (var i = 0; i < 10; i++) {
		a[i] = function () {
		console.log(i);
	};
	}
	console.log(a[6]()); // 10

	var b = [];
	for (let i = 0; i < 10; i++) {
		b[i] = function () {
		console.log(i);
	};
	}

	console.log(b[6]());

	for (let i=1;i<3;i++){
		console.log(i);
	}
	var tmp = 123;



/*
	function f() { console.log('I am outside!'); }
	
	(function () {
		if (false) {
		// 重复声明一次函数f
		function f() { console.log('I am inside!'); }
		}
	
	f();
	}());
	*/
	
	/*
	class RangeIterator {
		constructor(start,stop){
			this.value = start;
			this.stop = stop;
		}
		[Symbol.iterator](){
			return this;
		}
		next(){
			var value = this.value;
			if (value < this.stop ) {
				this.value++;
				return { value:value,done:false}
			} else {
				return {value:undefined,done:true}
			}

		}
	}

	function range(start,stop){
		return new RangeIterator(start,stop);
	}

	for (var value of range(0,10)){
		console.log(value);
	}*/

	/*
	var PENDING = 0;
            var FULFILLED = 1;
            var REJECTED = 2;
           
            function Promise(callback) {
                this.status = PENDING;
                this.value = null;
                this.defferd = [];
                setTimeout(callback.bind(this, this.resolve.bind(this), this.reject.bind(this)), 0);
            }
            
            Promise.prototype = {
                constructor: Promise,
                //触发改变promise状态到FULFILLED
                resolve: function (result) {
                    this.status = FULFILLED;
                    this.value = result;
                    this.done();
                },
                //触发改变promise状态到REJECTED
                reject: function (error) {
                    this.status = REJECTED;
                    this.value = error;
                },
                //处理defferd
                handle: function (fn) {
                    if (!fn) {
                        return;
                    }
                    var value = this.value;
                    var t = this.status;
                    var p;
                    if (t == PENDING) {
                         this.defferd.push(fn);
                    } else {
                        if (t == FULFILLED && typeof fn.onfulfiled == 'function') {
                            p = fn.onfulfiled(value);
                        }
                        if (t == REJECTED && typeof fn.onrejected == 'function') {
                            p = fn.onrejected(value);
                        }
                    var promise = fn.promise;
                    if (promise) {
                        if (p && p.constructor == Promise) {
                            p.defferd = promise.defferd;
                        } else {
                            p = this;
                            p.defferd = promise.defferd;
                            this.done();
                        }
                    }
                    }
                },
                //触发promise defferd里面需要执行的函数
                done: function () {
                    var status = this.status;
                    if (status == PENDING) {
                        return;
                    }
                    var defferd = this.defferd;
                    for (var i = 0; i < defferd.length; i++) {
                        this.handle(defferd[i]);
                    }
                },
                
                then: function (success, fail) {
                   var o = {
                        onfulfiled: success,
                        onrejected: fail
                    };
                    var status = this.status;
                    o.promise = new this.constructor(function () {
            
                    });
                    if (status == PENDING) {
                        this.defferd.push(o);
                    } else if (status == FULFILLED || status == REJECTED) {
                        this.handle(o);
                    }
                    //console.log(this);
                    //console.log(this===promise);
                    //console.log('-----');
                    return o.promise;
                }
            };
	
	*/
     var promise = new Promise((resolve,reject) => {
     	console.log('test1');
     	setTimeout(resolve,2000,'done222');
     })
	

	var promise2 = new Promise((resolve,reject) => {
     	console.log('test10');
     	setTimeout(resolve,5000,'done222');
     })
	
	promise.then(function(value){
		console.log('test2');
		console.log(value);
		//console.log(this);
		return 'success';
	}).then((value)=>{
		console.log('----');
		//console.log(this);
		console.log(value);
		return promise2;
	}).then(function(test){
		console.log('test');
	})

	console.log('test3');
	/*
	const p1 = new Promise(function (resolve, reject) {
		console.log(this);
		setTimeout(() => reject(new Error('fail')), 3000)
	})
	
	const p2 = new Promise(function (resolve, reject) {
		setTimeout(() => resolve(p1), 1000)
	})
	
	p2
	.then(result => console.log(result))
	.catch(error => console.log(error))*/



	 /* 

		类的test

	 */

	 class Point {
	 	constructor(){
	 		this.x = 3;
	 		this.y = 4;
	 	}
	 }

	 class ColorPoint extends Point{
	 	constructor(){
	 		super();
	 		this.color = 'red';
	 		//console.log(this);
	 	//console.log( super === Point )
	 	}
	 	test(){
	 		console.log('---');
	 		console.log(this);
	 	}
	 }

	 var point = new ColorPoint();

	 var obj = {
	 	get next(){
	 		return 3;
	 	},
	 	set next(newValue){

	 	}

	 }


	 

	 "use strict";

	function _classCallCheck(instance, Constructor) { 
		if (!(instance instanceof Constructor)) { 
			throw new TypeError("Cannot call a class as a function"); 
		}
	 }

	function _possibleConstructorReturn(self, call) { 
		if (!self) { 
			throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); 
		} 
		return call && (typeof call === "object" || typeof call === "function") ? call : self;
	 }

	function _inherits(subClass, superClass) { 
		if (typeof superClass !== "function" && superClass !== null) { 
			throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); 
		}
		 subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); 

		 if (superClass) 
		 	Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; 
	}

	var Child = function (_Parents) {
	  _inherits(Child, _Parents);

	  function Child() {
	    _classCallCheck(this, Child);

	    var _this = _possibleConstructorReturn(this, (Child.__proto__ || Object.getPrototypeOf(Child)).call(this));

	    _this.x = 3;
	    _this.y = 4;
	    return _this;
	  }

	  return Child;
	}(Parents);

	var Parents = function Parents() {
	  _classCallCheck(this, Parents);

	  this.z = 5;
	};
	
	

	var test = function(){
		return 4;
	}();
	 
  </script>
	}
</body>
</html>